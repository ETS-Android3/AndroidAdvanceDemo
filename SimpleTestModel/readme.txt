
    simpleTestModel说明文件

    pattern：设计模式模块，共有23种(只包含常用的基本设计模式):
            六大原则：
                    1.单一职责原则:
                        定义：一个类应只包含单一的职责。
                    2.开放封闭原则:
                        定义：一个模块、类、函数应当是对修改关闭，扩展开放。
                    3.里氏代换原则;
                        定义：使用父类的地方能够使用子类来替换，反过来，则不行。
                    4.依赖倒转原则:
                        定义：抽象不应该依赖于细节，细节应当依赖于抽象。
                    5.接口隔离法则:
                        定义：一个类对另一个类的依赖应该建立在最小的接口上。
                     6.迪米特法则:
                         定义：一个类尽量不要与其他类发生关系.

                         三大类：创建型模式；行为型模式；结构型模式。

                                        1.创建型模式（creational）：

        1.single:单例模式； 详细介绍地址：https://www.jianshu.com/p/d59c64480ed8
                           特点：1. 单例类只能有一个实例。
                                 2. 单例类必须自己创建自己的唯一实例。
                                 3. 单例类必须给所有其他对象提供这一实例。

        2.builder模式：参考AlertDialog.Builder源码；

        3.factory：工厂模式；源码可以参考BitmapFactory类等；

        4.prototype：原型模式： 源码可参考Intent等；
                            优点：可以解决复杂对象创建时消耗过多的问题，在某些场景下提升创建对象的效率；
                                  保护性拷贝，防止外部调用者对对象的修改，保证这个对象是只读的；
                            缺点：拷贝对象不会执行构造函数；
                                  有时需要考虑深拷贝和浅拷贝的问题；


                                        2. 行为型模式(behaviour)：

         1.template：模板方法模式; 源码可参考View类(自定义view时，绘制的步骤是固定的，具体实现时，重写ondraw等方法)等;
                            定义：一个流程有一套固定的步骤，但是具体的实现可以是不固定的。

                           优点：
                                提高代码复用性，去除子类中的重复代码。
                                提高扩展性，不同实现细节放到不同子类中，易于增加新行为。
                           缺点：
                                每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。

          2.strategy：策略模式： 源码可参考listview的setAdapter等；
                            优点：策略类可以互相替换（都实现同一个接口）；
                                  耦合都低，方便扩展（增加一个策略时只需添加一个策略类即可，基本不用修改原来的代码,符合开闭原则）；
                                  避免使用多重条件语句（if-else、switch等）；
                            缺点：策略的增多会导致子类变多；
                                  客户端需要知道所有策略，并自行决定使用哪个一个策略；

          3.state：状态模式：  状态模式中的行为是由状态来决定的，即不同状态下的行为也不同。
                              状态模式的结构跟策略模式的几乎一样，但其本质是不一样的。策略模式中的行为是彼此独立，能够相互替换的；而状态模式的行为是平行的，，不同状态下其行为也是不一样的，具有不可替换性。

          4.responsibility：责任链模式：

          5.观察者模式：rxjava、adapter的notifychange方法，rxandroid等；

          6.迭代器模式：list、map等的数据遍历；

           7.备忘录模式：activity中onSaveInstanceState的方法、Canvas中的Save（）和Restore（）等；

                                             3. 结构型模式(structural)：

        1.decorator:装饰者模式；  源码可以参考Context类等
                         优点：
                             采用组合的方式，可以动态的扩展功能，同时也可以在运行时选择不同的装饰器，来实现不同的功能。
                             有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。
                             被装饰者与装饰者解偶，被装饰者可以不知道装饰者的存在，同时新增功能时原有代码也无需改变，符合开放封闭原则。

                          缺点：
                             装饰层过多的话，维护起来比较困难。
                             如果要修改抽象组件这个基类的话，后面的一些子类可能也需跟着修改，较容易出错。






    proxy：代理模块(动态代理和静态代理);

    reflect：反射模块;